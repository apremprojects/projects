**Introduction**  
My project for this expedition is a waypoint system for the Polulu Romi Robot, which I discussed in my earlier README.md (link). I chose this project because I am interested in creating a robot that localizes using odometry, navigates to waypoints (a waypoint is a coordinate on the ground), and communicates its trajectory and current position with a PC using TCP. By choosing this project, I learned more about robot control and communication systems and GUI design.  
**Technical details**  
For this project, I used C++ and the Arduino Programming Language. The robot is the same two-wheel Arduino and Raspberry Pi system from earlier, with the robot firmware for this project based on the firmware from the last project. However, the major difference with this version is that the robot now has a waypoint system, enabling it to travel to coordinates provided by a computer over TCP/IP. Qt is used for a GUI, a Romi Robot control library from Polulu is used to control the robot’s motors, and queues (both fixed-size and dynamic) are used in several places to a list of waypoints the robot has to travel to.  
**Changes**  
For this project, no hardware changes to the robot itself were done, but the robot firmware was given a new waypoint system and a new Raspberry Pi control program was created to travel to waypoints provided over a TCP connection.  
**How does it work?**  
  The server-side program is a program that runs on the Raspberry Pi, which is sent new waypoints over a TCP connection from the client-side program. Upon receiving them, it sends them to the Arduino to process. It also gets information about the robot’s status (position, angle, queue fullness) and uses it to decide whether to send a new waypoint (if the queue is full it waits) and sends relevant status info to the client-side program.  
  The client-side program is a program that runs on a PC or Laptop and displays the robot’s current position, trajectory, and future waypoints. It sends new waypoints to the server-side program and gets the robot’s status (from the server-side program) and displays it on screen. It also has the option to reset the robot’s position to a user-provided origin.  
  The server-side program, running on the Raspberry Pi, communicates over serial with the Arduino. This option is chosen instead of the built-in I2C connection as it is vastly more reliable, easier to use for bidirectional communication, and helps with testing the firmware using a PC through the Arduino IDE. It sends the waypoints (obtained from the client-side program) to the Arduino, which handles traveling to the target waypoint. Unfortunately, due to limitations of the microcontroller, the queue is fixed-size, which means the robot can only store 4 waypoints. This is because using resizable queues involves using dynamic memory allocation, which is impossible for Arduino. To get around this, the server-side program only sends a waypoint if there is space in the Arduino’s queue. Also, the Arduino sends status information over serial, like position and angle, to the server-side program, which then sends it to the client-side program to display.  
  The Arduino handles low-level tasks that require quick action, like motor, angle, and waypoint control. Without an OS, and updating every 25ms, the Arduino can react very quickly. It measures its position and angle by integrating wheel velocity/velocity difference over time and travels to waypoints provided by the server-side program. It also sends status updates with the position, angle, and queue state to the server-side program.  
**What’s Serial/TCP?**  
  USB Serial link allows bidirectional communication between two devices using 3 data lines (TX, RX, and ground). It is relatively simple to use, as any type of data can be sent in any direction. For simplicity, I send ASCII messages, which are easily human-readable.  
  TCP/IP is a communication protocol that encapsulates data into packets and guarantees that it will be sent correctly (using checksums) and in order. Also, instead only being able to communicate with one thing, TCP, being implemented over the IP stack, has access to multiple ports (not physical, software). A computer has access to thousands of ports, which is why a computer can communicate with multiple devices at the same time. A serial connection can only happen between two devices, to do more, a new connection must be added, requiring new wiring. A computer can communicate over TCP with multiple devices without requiring additional wiring, just using another port, in the case of a desktop connected over Ethernet, just one cable allows it to communicate with hundreds of devices without special wiring for each device. It is not used for the Arduino to Raspberry Pi connection as the Arduino doesn’t support it and adding it would cause unnecessary complexity.  
**Things I learned**  
  * Cascaded PID controllers
  * TCP Communication
  * Qt GUI design
  * Complex bidirectional serial/TCP communication
**Things I applied**
  * Cross-platform build system with CMake (Works on Windows and Linux)
  * PID tuning
  * Efficient microcontroller programming
